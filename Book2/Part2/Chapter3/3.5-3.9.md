## 3.5 에러 처리
- 동기적인 `try ... catch` 구문은 개발자들이 대부분 익숙한 가장 일반적인 에러 처리 형태다.
- 아쉽게도 `try ... catch` 문은 동기적으로만 사용 가능하므로 비동기 코드 패턴에서는 무용지물이다.
  ```js
  function foo() {
    setTimeout(function() {
      baz.bar();
    }, 100);
  }
  try {
    foo();
    // 나중에 baz.bar() 에서 전역 에러 발생
  } catch {
    // 아무 에러도 실행되지 않음
  }
  ```
### 3.5.1 절망의 구덩이
- 프라미스에서 에러가 파묻히는 걸 막으려면 반드시 프라미스 연쇄 끝부분에 `catch()`를 써야 한다고 주장하는 개발자들이 있다.
  ```js
  var p = Promise.resolve(42);

  p.then(
    function fulfilled(msg) {
      // 42는 숫자이므로 다음 구문에서 에러가 발생함
      console.log(msg.toLowerCase());
    }
  )
  .catch(handleErrors);
  ```
  - `p`로 유입된 에러 및 `p` 이후 귀결 중 발생한 에러 (예를 들어 `msg.toLowerCase()`) 모두 `handleErrors`로 들어온다.
  - 만약 `handleErrors()` 함수에서 에러가 난다면? 여기서 방치된 프라미스가 하나 더 있는데, 바로 `catch()`가 반환한 프라미스다.
  - 그렇다고 무작정 연쇄 끝에 `catch()`를 하나 더 붙일 수도 없다. 이 함수 역시 실패할 수 있고, 프라미스 연쇄의 마지막 단계에 방치된 프라미스에서 에러가 나면 그 에러가 잡하지 않을 가능성은 (점점 낮아지긴 하겠지만) 항상 존재한다. 

### 3.5.2 잡히지 않은 에러 처리
- 프라미스에서 잡히지 않은 에러를 처리할 수 있다며 사람들이 이런저런 방안을 제시했는데,
1. 일부 프라미스 라이브러리는 '전역 미처리 버림 `Global Unhandled Rejection`' 처리기 같은 것을 등록하는 메서드를 추가하여 전역 범위로 에러를 던지는 대신 이 메서드가 대신 호출되도록 해놓았다.
   - 그러나 잡히지 않은 에러인지 식별하기 위해 버림 직후 임의의 시간 동안 타이머를 걸어놓는 식으로 구현한 것이다. 여기서 임의의 시간 자체가 주관적이거니와 가끔은 일정 시간 프라미스가 버림 상태로 유지시켜야 할 때도 있기 때문에 잡하지 않은 에러 처리기가 모든 긍정 오류 (미처리 상태의 잡히지 않은 에러) 발생 시 호출되기를 바라는 사람은 없을 것이다.  
2. 프라미스 연쇄 끝에 `done()`을 붙여 완료 사실을 천명해야 한다고 조언하는 사람들도 있다. `done()`은 프라미스를 생성, 반환하는 함수가 아니므로 `done()` 버림 처리기 내부에서 에러가 발생하면 잡히지 않은 전역 에러로 던져진다.
   - 이 방식의 문제점은 `done()`이 `ES6` 표준에 들어있지 않다는 것이다. 따라서 믿을 만한 보편적인 해결 방안과는 거리가 멀다.
3. 브라우저는 언제 어떤 객체가 휴지통으로 직행하여 가비지 콜렉션될지 정확히 알고 추적할 수 있다. 따라서 브라우저는 프라미스 객체를 추적하면서 언제 가비지를 수거하면 될지 분명히 알고 있으며, 프라미스가 버려지면 그 사유가 논리적인, 잡히지 않은 에러이므로 개발자 콘솔창에 표시해야 할지 여부를 확실하게 결정할 수 있다.
   - 그러나 프라미스가 제대로 가비지 콜렉션되지 않으면 (코딩 패턴이 뒤죽박죽이다보면 그렇게 되기 쉽다) 브라우저의 가비지 콜렉션 감지 기능은 도처에 널려있는 버림 프라미스를 파악/진단하는 데에 도움이 되지 않는다.

### 3.5.3 성공의 구덩이
- 기본적으로 프라미스는 그다음 잡/이벤트 루프 틱 시점에 에러 처리기가 등록되어 있지 않을 경우 모든 버림을 개발자 콘솔창에 알리도록 되어 있다.
- 감지되기 전까지 버림 프라미스의 버림 상태를 계속해서 유지하려면 `defer()`를 호출해서 해당 프라미스에 관한 자동 에러 알림 기능을 끈다.

## 3.6 프라미스 패턴
### 3.6.1 `Promise.all()`
- 복수의 병렬/동시 작업이 끝날 때까지 진행하지 않고 대기하는 패턴이다. 예를 들면,
  ```js
  var p1 = request("http://some.url.1/");
  var p2 = request("http://some.url.2/");

  Promise.all([p1, p2])
  .then(function(msgs) {
    return request(
      "http://some.url.3/?v=" + msgs.join(",")
    );
  })
  .then(function(msg) {
    console.log(msg);
  });
  ```
  - `Promise.all([ ])`는 보통 프라미스 인스턴스들이 담긴 배열 하나를 인자로 받고, 호출 결과 반환된 프라미스는 이룸 메세지 `msg`를 수신한다. 이 메시지는 배열에 나열한 순서대로 프라미스들을 통과하면서 얻어진 이룸 메시지의 배열이다. `Promise.all([ ])`이 반환한 메인 프라미스는 자신의 하위 프라미스들이 모두 이루어져야 이루어질 수 있다. 단 한 개의 프라미스라도 버려지면 `Promise.all([ ])` 프라미스 역시 곧바로 버려지며 다른 프라미스 결과도 덩달아 무효가 된다.
 
### 3.6.2 `Promise.race()`
- `Promise.race([ ])`는 가장 먼저 이루어진 프라미스의 결과값을 그대로 이행하고, 한편 하나라도 버려지는 프라미스가 있으면 버려진다. (아래 예제는 mdn web docs의 `Promise.race()`에 대한 설명에서 가져왔다.)
  ```js
  const promise1 = new Promise((resolve, reject) => {
    setTimeout(resolve, 500, 'one');
  });
  
  const promise2 = new Promise((resolve, reject) => {
    setTimeout(resolve, 100, 'two');
  });
  
  Promise.race([promise1, promise2]).then((value) => {
    console.log(value);
    // Both resolve, but promise2 is faster
  });
  // Expected output: "two"
  ```
### 3.6.3 `all(), race()`의 변형
- 프라미스 패턴 중에 자주 쓰이는 것들이 있다.
  - `Promise.any()`
    - 이터러블 가운데 어느 하나의 프라미스라도 성공하면 프라미스를 반환한다.
   
## 3.7 프라미스 API 복습
### 3.7.1 new Promise() 생성자
- `Promise()` 생성자는 항상 `new`와 함께 사용한다.

### 3.7.2 `Promise.resolve()`와 `Promise.reject()`  
- `Promise`는 매개변수로 두가지 함수를 받는데, 첫 번째 함수인 `resolve`는 비동기 작업을 성공적으로 완료해 결과를 값으로 반환할 때 호출해야 하고, 두 번째 함수인 `reject`는 작업이 실패하여 오류의 원인을 반환할 때 호출한다.

### 3.7.3 `then()`과 `catch()`
- `then()`은 하나 또는 두 개의 인자를 받는데 첫 번째는 프라미스가 이행됐을 때, 두 번째는 프라미스가 거부됐을 때를 위한 콜백 함수다. 어느 한쪽은 누락하거나 함수가 아닌 값으로 지정하며 각각 기본 콜백으로 대체된다. 기본 `resolve`는 그냥 메시지를 전달하기만 하고, 기본 `reject`는 단순히 전달받은 에러 사유를 전파한다.
- `catch()`는 프라미스가 거부된 경우에 대한 콜백 함수를 매개변수로 받는다.

### 3.7.4 `Promise.all()`과 `Promise.race()`
- `Promise.all()`은 주어진 모든 프라미스들이 이루어져야 메인 프라미스도 이루어지고 단 하나라도 버려지게 되면 메인 반환 프라미스 역시 곧바로 폐기된다.
- `Promise.race()`는 오직 최초로 귀결된 프라미스만 이룸이든 버림이든 반환된다.

## 3.8 프라미스 한계
### 3.8.1 시퀀스 에러 처리
- 프라미스 연쇄에서 에러가 나면 그냥 조용히 묻혀버리기 쉽다.
- 프라미스 연쇄는 구성원들을 한데 모아놓은 사슬에 불과하기 때문에 전체 연쇄를 하나로 가리킬 `Entity`가 마땅치 않다. 즉 일어날지 모를 에러를 밖에서는 감지할 도리가 없다.
  - 에러 처리기가 없는 프라미스 연쇄에서 에러가 발생하면 나중에 어딘가에서 감지될 때까지 그 에러는 연쇄를 따라 쭉 하위로 전파된다. 이런 경우, 연쇄의 마지막에 에러 처리기 `catch()`를 등록하면 전파되어 내려온 에러를 처리할 수 있다.
  ```js
  p.catch(handleErrors);
  ```
  - 하지만 연쇄의 어느 단계에서 나름대로 에러 처리를 하면 `handleErrors()`는 에러를 감지할 방법이 없다. 이게 당초 의도한 바(Handled Rejection)일 수도 있지만, 그렇지 않을 수도 있다. 이것은 `try ... catch` 문에 기본적으로 존재하는 한계로, 예외가 잡혀도 그냥 묻혀버릴 가능성은 얼마든지 있다. 
### 3.8.2 단일값
- 프라미스는 정의상 하나의 이룸값, 아니면 하나의 버림 사유를 가진다.
- 메시지를 여러 개 담아둘 객체나 배열을 만들면 되고 잘 작동하긴 하겠지만, 프라미스 연쇄의 단계마다 메시지를 감싸고 푸는 일은 무척 불편할 것이다.
### 3.8.3 단일 귀결
- 프라미스가 단 1회만 귀결된다는 점은 프라미스의 가장 중요한 본질이다.
### 3.8.5 프라미스는 취소 불가
- 일단 프라미스를 생성하여 `resolve` `reject`를 등록하면, 도중에 작업 자체를 의미없게 만드는 일이 발생하더라도 외부에서 프라미스 진행을 멈출 방법이 없다.
### 3.8.6 프라미스 성능
- 콜백식 비동기 작업 연쇄와 프라미스 연쇄의 움직이는 코드 조각이 얼마나 되는지 살펴보면 아무래도 프라미스가 처리량이 많고 그래서 속도 역시 약간 더 느린 게 사실이다.
- 프라미스가 모든 것을 비동기화한다는 논란도 있다. 어느 정도 즉시 완료된 단계들이 여전히 다음 단계의 잡 진행을 지연시킨다는 것이다. 즉 콜백식 시퀀스에 비해 일련의 프라미스 작업이 아주 미미하나마 더 늦게 끝날 가능성이 있다는 소리다.

## 3.9 정리하기
- 프라미스는 훌륭하다. 콜백식 코드에서 줄곧 목의 가시였던 제어의 역전 문제를 프라미스가 한방에 해결했다.
- 프라미스가 콜백을 완전히 없애는 건 아니지만, 기존의 콜백 코드를 믿을만한 중계자 역할을 수행하는 유틸리티를 통해 잘 조정하여 서로 조화롭게 작동할 수 있도록 유도한 것이다.
- 프라미스 연쇄는 비동기 흐름을 순차적으로 표현하는 더 나은 방법이다. 덕분에 우리 두뇌가 비동기 자바스크립트를 더 효율적으로 계획/관리할 수 있다.
