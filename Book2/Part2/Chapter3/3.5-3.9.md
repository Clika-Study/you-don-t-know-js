## 3.5 에러 처리
- 동기적인 `try ... catch` 구문은 개발자들이 대부분 익숙한 가장 일반적인 에러 처리 형태다.
- 아쉽게도 `try ... catch` 문은 동기적으로만 사용 가능하므로 비동기 코드 패턴에서는 무용지물이다.
  ```js
  function foo() {
    setTimeout(function() {
      baz.bar();
    }, 100);
  }
  try {
    foo();
    // 나중에 baz.bar() 에서 전역 에러 발생
  } catch {
    // 아무 에러도 실행되지 않음
  }
  ```
### 3.5.1 절망의 구덩이
- 프라미스에서 에러가 파묻히는 걸 막으려면 반드시 프라미스 연쇄 끝부분에 `catch()`를 써야 한다고 주장하는 개발자들이 있다.
  ```js
  var p = Promise.resolve(42);

  p.then(
    function fulfilled(msg) {
      // 42는 숫자이므로 다음 구문에서 에러가 발생함
      console.log(msg.toLowerCase());
    }
  )
  .catch(handleErrors);
  ```
  - `p`로 유입된 에러 및 `p` 이후 귀결 중 발생한 에러 (예를 들어 `msg.toLowerCase()`) 모두 `handleErrors`로 들어온다.
  - 만약 `handleErrors()` 함수에서 에러가 난다면? 여기서 방치된 프라미스가 하나 더 있는데, 바로 `catch()`가 반환한 프라미스다.
  - 그렇다고 무작정 연쇄 끝에 `catch()`를 하나 더 붙일 수도 없다. 이 함수 역시 실패할 수 있고, 프라미스 연쇄의 마지막 단계에 방치된 프라미스에서 에러가 나면 그 에러가 잡하지 않을 가능성은 (점점 낮아지긴 하겠지만) 항상 존재한다. 

### 3.5.2 잡히지 않은 에러 처리
- 프라미스에서 잡히지 않은 에러를 처리할 수 있다며 사람들이 이런저런 방안을 제시했는데,
1. 일부 프라미스 라이브러리는 '전역 미처리 버림 `Global Unhandled Rejection`' 처리기 같은 것을 등록하는 메서드를 추가하여 전역 범위로 에러를 던지는 대신 이 메서드가 대신 호출되도록 해놓았다.
   - 그러나 잡히지 않은 에러인지 식별하기 위해 버림 직후 임의의 시간 동안 타이머를 걸어놓는 식으로 구현한 것이다. 여기서 임의의 시간 자체가 주관적이거니와 가끔은 일정 시간 프라미스가 버림 상태로 유지시켜야 할 때도 있기 때문에 잡하지 않은 에러 처리기가 모든 긍정 오류 (미처리 상태의 잡히지 않은 에러) 발생 시 호출되기를 바라는 사람은 없을 것이다.  
2. 프라미스 연쇄 끝에 `done()`을 붙여 완료 사실을 천명해야 한다고 조언하는 사람들도 있다. `done()`은 프라미스를 생성, 반환하는 함수가 아니므로 `done()` 버림 처리기 내부에서 에러가 발생하면 잡히지 않은 전역 에러로 던져진다.
   - 이 방식의 문제점은 `done()`이 `ES6` 표준에 들어있지 않다는 것이다. 따라서 믿을 만한 보편적인 해결 방안과는 거리가 멀다.
3. 브라우저는 언제 어떤 객체가 휴지통으로 직행하여 가비지 콜렉션될지 정확히 알고 추적할 수 있다. 따라서 브라우저는 프라미스 객체를 추적하면서 언제 가비지를 수거하면 될지 분명히 알고 있으며, 프라미스가 버려지면 그 사유가 논리적인, 잡히지 않은 에러이므로 개발자 콘솔창에 표시해야 할지 여부를 확실하게 결정할 수 있다.
   - 그러나 프라미스가 제대로 가비지 콜렉션되지 않으면 (코딩 패턴이 뒤죽박죽이다보면 그렇게 되기 쉽다) 브라우저의 가비지 콜렉션 감지 기능은 도처에 널려있는 버림 프라미스를 파악/진단하는 데에 도움이 되지 않는다.

### 3.5.3 성공의 구덩이
- 기본적으로 프라미스는 그다음 잡/이벤트 루프 틱 시점에 에러 처리기가 등록되어 있지 않을 경우 모든 버림을 개발자 콘솔창에 알리도록 되어 있다.
- 감지되기 전까지 버림 프라미스의 버림 상태를 계속해서 유지하려면 `defer()`를 호출해서 해당 프라미스에 관한 자동 에러 알림 기능을 끈다.

## 3.6 프라미스 패턴
### 3.6.1 `Promise.all()`
- 복수의 병렬/동시 작업이 끝날 때까지 진행하지 않고 대기하는 패턴이다. 예를 들면,
  ```js
  var p1 = request("http://some.url.1/");
  var p2 = request("http://some.url.2/");

  Promise.all([p1, p2])
  .then(function(msgs) {
    return request(
      "http://some.url.3/?v=" + msgs.join(",")
    );
  })
  .then(function(msg) {
    console.log(msg);
  });
  ```
  - `Promise.all([ ])`는 보통 프라미스 인스턴스들이 담긴 배열 하나를 인자로 받고, 호출 결과 반환된 프라미스는 이룸 메세지 `msg`를 수신한다. 이 메시지는 배열에 나열한 순서대로 프라미스들을 통과하면서 얻어진 이룸 메시지의 배열이다. `Promise.all([ ])`이 반환한 메인 프라미스는 자신의 하위 프라미스들이 모두 이루어져야 이루어질 수 있다. 단 한 개의 프라미스라도 버려지면 `Promise.all([ ])` 프라미스 역시 곧바로 버려지며 다른 프라미스 결과도 덩달아 무효가 된다.
 
### 3.6.2 `Promise.race()`
- `Promise.race([ ])`는 가장 먼저 이루어진 프라미스의 결과값을 그대로 이행하고, 한편 하나라도 버려지는 프라미스가 있으면 버려진다. (아래 예제는 mdn web docs의 `Promise.race()`에 대한 설명에서 가져왔다.)
  ```js
  const promise1 = new Promise((resolve, reject) => {
    setTimeout(resolve, 500, 'one');
  });
  
  const promise2 = new Promise((resolve, reject) => {
    setTimeout(resolve, 100, 'two');
  });
  
  Promise.race([promise1, promise2]).then((value) => {
    console.log(value);
    // Both resolve, but promise2 is faster
  });
  // Expected output: "two"
  ```
### 3.6.3 `all(), race()`의 변형
