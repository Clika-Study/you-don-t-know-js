## 3.5 에러 처리
- 동기적인 `try ... catch` 구문은 개발자들이 대부분 익숙한 가장 일반적인 에러 처리 형태다.
- 아쉽게도 `try ... catch` 문은 동기적으로만 사용 가능하므로 비동기 코드 패턴에서는 무용지물이다.
  ```js
  function foo() {
    setTimeout(function() {
      baz.bar();
    }, 100);
  }
  try {
    foo();
    // 나중에 baz.bar() 에서 전역 에러 발생
  } catch {
    // 아무 에러도 실행되지 않음
  }
  ```
### 3.5.1 절망의 구덩이
- 프라미스에서 에러가 파묻히는 걸 막으려면 반드시 프라미스 연쇄 끝부분에 `catch()`를 써야 한다고 주장하는 개발자들이 있다.
  ```js
  var p = Promise.resolve(42);

  p.then(
    function fulfilled(msg) {
      // 42는 숫자이므로 다음 구문에서 에러가 발생함
      console.log(msg.toLowerCase());
    }
  )
  .catch(handleErrors);
  ```
  - `p`로 유입된 에러 및 `p` 이후 귀결 중 발생한 에러 (예를 들어 `msg.toLowerCase()`) 모두 `handleErrors`로 들어온다.
  - 만약 `handleErrors()` 함수에서 에러가 난다면? 여기서 방치된 프라미스가 하나 더 있는데, 바로 `catch()`가 반환한 프라미스다.
  - 그렇다고 무작정 연쇄 끝에 `catch()`를 하나 더 붙일 수도 없다. 이 함수 역시 실패할 수 있고, 프라미스 연쇄의 마지막 단계에 방치된 프라미스에서 에러가 나면 그 에러가 잡하지 않을 가능성은 (점점 낮아지긴 하겠지만) 항상 존재한다. 

### 3.5.2 잡히지 않은 에러 처리
- 프라미스에서 잡히지 않은 에러를 처리할 수 있다며 사람들이 이런저런 방안을 제시했는데,
1. 일부 프라미스 라이브러리는 '전역 미처리 버림 `Global Unhandled Rejection`' 처리기 같은 것을 등록하는 메서드를 추가하여 전역 범위로 에러를 던지는 대신 이 메서드가 대신 호출되도록 해놓았다.
   - 그러나 잡히지 않은 에러인지 식별하기 위해 버림 직후 임의의 시간 동안 타이머를 걸어놓는 식으로 구현한 것이다. 여기서 임의의 시간 자체가 주관적이거니와 가끔은 일정 시간 프라미스가 버림 상태로 유지시켜야 할 때도 있기 때문에 잡하지 않은 에러 처리기가 모든 긍정 오류 (미처리 상태의 잡히지 않은 에러) 발생 시 호출되기를 바라는 사람은 없을 것이다.  
2. 프라미스 연쇄 끝에 `done()`을 붙여 완료 사실을 천명해야 한다고 조언하는 사람들도 있다. `done()`은 프라미스를 생성, 반환하는 함수가 아니므로 `done()` 버림 처리기 내부에서 에러가 발생하면 잡히지 않은 전역 에러로 던져진다.
   - 이 방식의 문제점은 `done()`이 `ES6` 표준에 들어있지 않다는 것이다. 따라서 믿을 만한 보편적인 해결 방안과는 거리가 멀다.
3. 브라우저는 언제 어떤 객체가 휴지통으로 직행하여 가비지 콜렉션될지 정확히 알고 추적할 수 있다. 따라서 브라우저는 프라미스 객체를 추적하면서 언제 가비지를 수거하면 될지 분명히 알고 있으며, 프라미스가 버려지면 그 사유가 논리적인, 잡히지 않은 에러이므로 개발자 콘솔창에 표시해야 할지 여부를 확실하게 결정할 수 있다.
   - 그러나 프라미스가 제대로 가비지 콜렉션되지 않으면 (코딩 패턴이 뒤죽박죽이다보면 그렇게 되기 쉽다) 브라우저의 가비지 콜렉션 감지 기능은 도처에 널려있는 버림 프라미스를 파악/진단하는 데에 도움이 되지 않는다.
