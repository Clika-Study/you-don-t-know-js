## 3.5 에러 처리
- 동기적인 `try ... catch` 구문은 개발자들이 대부분 익숙한 가장 일반적인 에러 처리 형태다.
- 아쉽게도 `try ... catch` 문은 동기적으로만 사용 가능하므로 비동기 코드 패턴에서는 무용지물이다.
  ```js
  function foo() {
    setTimeout(function() {
      baz.bar();
    }, 100);
  }
  try {
    foo();
    // 나중에 baz.bar() 에서 전역 에러 발생
  } catch {
    // 아무 에러도 실행되지 않음
  }
  ```
### 3.5.1 절망의 구덩이
- 프라미스에서 에러가 파묻히는 걸 막으려면 반드시 프라미스 연쇄 끝부분에 `catch()`를 써야 한다고 주장하는 개발자들이 있다.
  ```js
  var p = Promise.resolve(42);

  p.then(
    function fulfilled(msg) {
      // 42는 숫자이므로 다음 구문에서 에러가 발생함
      console.log(msg.toLowerCase());
    }
  )
  .catch(handleErrors);
  ```
  - `p`로 유입된 에러 및 `p` 이후 귀결 중 발생한 에러 (예를 들어 `msg.toLowerCase()`) 모두 `handleErrors`로 들어온다.
  - 만약 `handleErrors()` 함수에서 에러가 난다면? 여기서 방치된 프라미스가 하나 더 있는데, 바로 `catch()`가 반환한 프라미스다.
  - 그렇다고 무작정 연쇄 끝에 `catch()`를 하나 더 붙일 수도 없다. 이 함수 역시 실패할 수 있고, 프라미스 연쇄의 마지막 단계에 방치된 프라미스에서 에러가 나면 그 에러가 잡하지 않을 가능성은 (점점 낮아지긴 하겠지만) 항상 존재한다. 
