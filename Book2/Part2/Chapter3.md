## 3.1 프라미스란?

개발자들은 새로운 것을 학습할 때 기술/패턴을 먼저 보는 경향이 있다. 하지만 API가 지양하고자 하는 것이 무엇인지 알고 쓰는 것과 아닌 것은 차이가 크고 그 차이를 느끼게 해주는 것이 프라미스다.

### 3.1.1 미랫값

예를 들어 식당에서 우리는 주문 후 영수증을 받게 된다. 이후 음식을 기다리는 과정에서 우리는 영수증에서 아직 받지 못한 음식이 나올 것이라고 사고 한다. 이 과정에서 영수증이 약속이고 음식이 미랫값이다. 하지만 음식의 제고가 떨어져 못 나오는 경우도 발생할 수 있듯이 미랫값은 성공 아니면 실패가 될 수 있다.

이와 같이 프라미스는 미래에 얻을 수 있는 값을 나타내며, 그 값은 아직 결정되지 않았을 수도 있습니다. 이 값이 결정되면 프라미스는 '이행' 상태 또는 '거부' 상태가 됩니다.

다시 코드로 돌아와서 우리는 개발을 할 때 항상 값이 미리 존재한다는 가정한 후 개발을 한다. 하지만 만약 존재하지 않으면 어떻게 될까?

```jsx
var x, y = 2; 
console.log(x+y) // 4s
```

위의 코드에서 만약 x가 비동기 코드라면 c의 동작은 혼돈 그 자체일 것이다.

그럴 때 우리는 프라미스를 사용할 수 있다. 물론 콜백도 사용이 가능하지만, 코드가 매우 더러워진다. 프라미스는 항상 이룸( fulfillment) 아니면 버림(Rejection)으로 귀결될 수 있기에 좀 더 코드가 예상할 수 있는 방향으로 개발을 할 수 있다.

## 3.2 데너블 덕 타이핑

어떤 값이 진짜 프라미스인지 정말 프라미스처럼 동작하는지 어떻게 알 수 있을까?

- 진짜 프라미스는 then() 매서드를 가진 데너블이라는 객체 는 함수를 정의하여 판별하는 걸로 규정되어 있다. then 매서드를 가지고 있으면 무조건 프라미스 규격에 맞는 것이다.
    - 평범한 객체더라도 then이라는 매서드를 가지게 되면 엔진이 데너블로 인식하여 특별한 규칙을 적용하기에 조심 해야 한다.
- 덕타이핑은 어떤 값의 타입을 그 형태를 보고 짐작하는 타입 체크이다.

## 3.3 프라미스 믿음

콜백만 사용했을 때의 믿음성 문제점

- 너무 일찍 콜백을 호출
- 너무 늦게 콜백을 호출(또는 전혀 호출하지 않음)
- 너무 적은 게 아니면 너무 많이 콜백을 호출
- 필요한 환경/인자를 정상적으로 콜백에 전달 못 함
- 발생할 수 있는 에러/예외를 무시

### 3.3.1 너무 빨리 호출

- 자르고 현상: 같은 작업인데 어떨 때는 동기적으로, 어떨 때는 비동기적으로 끝나 결국 경합 조건에 이르게 되는 현상이다.

프라미스는 프라미스의 정의상 동기적으로 볼 수 는 없으니 이 문제는 영향받을 일이 없다.

따라서 프라미스의 then에 등록된 콜백은 항상 비동기적으로만 부른다.

### 3.3.2 너무 늦게 호출

프라미스가 귀결되면 then()에 등록된 콜백들이 그다음 비동기 기회가 찾아왔을 때 순서대로 실행되며 어느 한 콜백 내부에서 다른 콜백의 호출에 영향을 주거나 지연시킬 수는 없다.

```jsx
 p.then(()=>{
	 p.then(()=>{
	 console.log(c) // c는 b보다 일찍 출력될 수 없다.
	 }
	 console.log(a)
 }
 console.log(b)

```

주의해야 할 점은 별개의 여러 프라미스 사이의 연쇄된 콜백사이의 상대적인 순서는 장담할 수 없기에 이런 방식의 코드는 피하는 것이 좋다.

### 3.3.3 한 번도 콜백을 안 호출

흔한 상황이고 프라미스로 해결할 수 있다.

경합이라는 상위 수준의 추상화를 이용하면 프라미스로 해결할 수 있다.

저자는 프라미스 타임아웃 패턴을 이용하여 해결하였는데 이 부분은 뒤에서 자세히 설명한다고 한다.

### 3.3.4 너무 가끔, 너무 종종 호출

- 너무 가끔
    
    콜백의 호출 횟수는 1번인데 너무 가끔의 뜻은 0번 호출하는 것이기에 즉 한 번도 콜백을 안호출과 같다.
    
- 너무 종종
    
    프라미스는 정의상 단 한 번만 귀결되기에 프라미스 생성 코드가 resolve() 나 reject() 중 하나 또는 모두를 여러 번 호출하려 할 때 최초의 귀결만 취하고 이후는 무시하게 된다.
    

### 3.3.5 인자/환경 전달 실패

프라미스 귀결 값은 딱 하나이고 명시적인 값으로 귀결되지 않으면 undefined가 된다.

주의할 점은  resolve(), reject() 함수를 부를 때 인자 두 번째 이후부터는 무시가 된다. 그래서 여러 개의 값을 넣고 싶으면 배열이나 객체를 사용해야 한다.

### 3.3.6 에러/예외 삼키기

프라미스가 생성중 또는 귀결을 기다리는 도중 에러가 발생한다면 예외를 잡아 주어진 프라미스를 강제로 버리게 된다.

여기서 발생한 에러는 프라미스 버림 콜백에서 잡아 대응이 가능하다.

### 3.3.7 미더운 프라미스?

Promise.resolve() 함수를 사용하면 값으로 이루어진 프라미스를 얻을 수 있는데. Promise.resolve() 를 거치게 되면 정규화를 하기에 안전한 결과를 얻을 수 있다.

## 3.4 연쇄 흐름

- 흐름 제어를 연쇄 할 수 있는 프라미스 고유의 특징
    1. then()을 호출하면 그 결과 자동으로 새 프라미스를 생성하여 봔환한다.
    2. 이룸/버림 처리기 안에서 어떤 값을 반환하거나 예외를 던지면 이에 따라 새 프라미스가 귀결된다.
    3. 이룸/버림 처리기가 반환한 프라미스는 풀린 상태로 그 귀결 값이 무엇이든 간데 결국 현재의 then()에서 반환된 연쇄 프라미스의 귀결값이 된다.

하지만 then 과 function을 남발하는 것은 콜백에 비해 나아졌지만 여전히 문제이다. 2부 4장 제네레이터에서 순차적으로 표현하는 법을 알려준다.

### 3.4.1 용어 정의: 귀결, 이룸, 버림

```jsx
var p = new Promise((X,Y)=>{
	//X() 는 이룸
	//Y() 는 버림 
})
```

이 책에서의 저자는 Promise의 콜백인자의 명칭으로 resolve와 refect를 추천했고 then에 제공할 콜백명으로는 fulfilled 와 rejected 라고 부르는 것을 추천하였다.