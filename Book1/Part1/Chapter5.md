# **Chapter 5. 문법**

## 5.1 문과 표현식

**문**은 문장, **표현식**은 어구, **연산자**는 접속사에 해당한다.

```jsx
var a = 3 * 6; // a = 3 * 6 부분이 표현식이고 이줄은 문이다.
var b = a; // b = a; 부분이 표현식
b; // b 가 표현식의 전부이지만 이것도 완전한 문이다.
```

- 표현식은 단일한, 특정 결괏값으로 계산된다.
- 선언문

  위의 코드에서 `var a = 3 * 6`과 같이 변수를 선언하는 문을 선언문이라 한다.

- 할당 표현식

  위의 코드에서 `a = 3 * 6` , `b = a` 같은 표현식을 할당 표현식이라 한다.

- 모든 문은 완료 값을 가진다.
- 문의 완료 값을 확인하는 가장 쉬운 방법은 브라우저의 콘솔 창에 코드를 입력하는 것이다.
- 우리가 흔히 변수를 선언할 때 `undefined`가 출력이 되는데 그것이 완료 값이었다!
- {} 코드 블록은 마지막 코드의 완료 값을 자신의 완료 값으로 반환한다.

```jsx
if (true) {
	const a = 1 ; 
	a + 1 // 완료 값은 2 된다.
}
```

- 하지만 문의 완료 값을 포착하여 사용하는 것은 쉬운 구문으로는 불가능 하다.
    - `eval` 함수를 사용하는 방법 (권장하는 방법은 아님)

        ```jsx
        var a, b ; 
        a = eval("if (true) {b = 4 + 38;}");
        a // 42
        ```


    - `do` 표현식 사용하는 방법
        
        ```jsx
        var a, b; 
        a = do {
        	if (true) {
        		b = 4 +32 ;
        	}
        };
        a // 42
        ```
        
        do 표현식은 블록 내 완료 값을 do 표현식 전체의 완료 값으로 반환한다.

- 대부분의 표현식에는 부수 효과가 없다.
- 부수 효과의 대표적인 예

    ```jsx
    function foo() {
    	a = a + 1;
    }
    var a = 1 ; 
    foo() // 완료값 undefined 부수효과 a의 값이 변경됨 
    ```

- ++ or — 연산자

  ++ 연산자는 주로 전위 또는 후위로 사용한다.

    - 전위로 사용 시 표현식 값이 반환 전 부수 효과가 발생한다.
    - 후위로 사용 시 표현식 값을 반환 후 부수 효과가 발생한다.
    - 부수 효과를 반환 전 사용하려면 문을 나열하는 콤마 연산자를 사용하여 다수의 개별 표현식을 나열할 수 있다.

    ```jsx
    var a = 32 
    a++ // 32
    a // 33
    var b = 32 
    ++b // 33
    b //33
    var c = 32
    (c++, c) //33
    c // 33
    ```

- 객체의 프로퍼티나 배열 슬롯을 제거할 때 쓰는 delete 역시 부수 효과를 일으키는 연산자이다.
    - delete는 단독으로 사용하는 경우가 많다.
    - delete 연산자의 결괏값은 유용한/허용된 연산일 경우 true 그 외에는 false다.
    - 프로퍼티나 배열 슬롯을 제거하는 것이 부수 효과이다.
- = 연산자의 값 할당도 부수 효과이다.
- 자바스크립트에는 goto 가 없는 대신 레이블 점프가 있다.
    - continue 나 break 뒤에 선택적으로 레이블을 받아 프로그램 실행을 점프시킬 수 있다.

## 5.2 연산자 우선순위

- 연산자가 여러 개일 경우 사용되는 규칙을 연산자 우선순위라고 한다.
- 연산자별로 우선순위가 정해져 있는데 이것 때문에 왼쪽부터 실행될 것으로 생각하는 사람들은 본인의 예상과는 다른 결과를 얻게 되는 원인이다.
- 연산자 우선순위에 관해서는 MDN 에 자세히 나와 있다.

  [연산자 우선순위 - JavaScript | MDN](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Operator_precedence)

- 단락 평가란 조건문에서 앞의 연산자에서 결과가 예상되면 뒤의 코드를 실행하지 않는 것이다.
- () 을 사용하여 우리가 어느 정도 연산 순위를 정해 줄 수 있는데 너무 남발하거나 아예 상용하지 않는 것 보단 가독성을 중점으로 사용하는 것을 권장하고 있다.

## 5.3 세미콜론 자동 삽입

- ASI는 세미콜론이 누락된 곳에 엔진이 자동으로 삽입하는 것을 말한다.
- 새줄(행 바꿈)에만 적용된다.
- 문 블록에서 세미콜론은 필 수가 아니다.
- ASI는 주로 break, continue, return,yield 키워드가 있는 곳에서 활약함
- 하지만 ASI에 너무 의존하는 것은 좋지 못하다.

## 5.4 에러

- 조기 에러는 컴파일 과정에서 발생한다.
- 이런 에러는 try ~ catch 문으로 잡을 수 없다.
- 잘못된 정규 표현식은 구문상 문제가 없지만 조기 에러가 발생한다.
- ES5 엄격 상태는 조기 에러가 더 많다.
- 임시 데드존(TDZ)은 변수 참조가 안 되는 부분이다.
- 임시 데드존은 선언되지 않은 변수는 참조가 될 수 없다.

## 5.5 함수 인자

- 함수 인자에서도 TDZ관련 에러를 찾을 수 있다.

    ```jsx
    var b = 3 ; 
    function foo(a = 42, b = a + b + 5 ) {
     // ... 
    }
    ```

  위의 코드에서 좌변 b는 아직 TDZ에 남아있는 b를 참조하려 하기에 에러가 발생한다.

- 인자를 넘기지 않으면 기본 값으로 undefined 가 지정이 되지만 argument에는 저장이 안된다.

## 5.6 try … finally

- finally블록은 try 문 이후 항상 실행된다.
- finally문은 이전 실행된 try 나 catch 절의 리턴을 덮어 씌우는 특징이 있다.

    ```jsx
    try {
    	 return 32
    }
    finally {
    	return 42
    }
    //결과는 42가 된다.
    ```

  하지만 finally에서 return을 하지 않으면 이전 실행된 return 이 그대로 실행된다.


## 5.7 switch

- case 표현 식의 매치 과정은 === 과 똑같다 .
- case 표현 식에 동등 비교(==)을 사용하고 싶다면 꼼수를 사용해야 한다.

    ```jsx
    var a = "42" 
    switch (true) {
    	case a == 10: 
    		break
    	case a == 42:
    		break
    	default: 
    		break
    }
    ```

    - case 표현 식의 결과가 엄격하게 ture가 아닐 경우 매치가 실패한다.