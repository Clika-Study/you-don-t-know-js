## 배열

- 자바스크립트에서의 배열은 문자열, 숫자, 객체 심지어 다른 배열이나 어떤 타입의 값이라도 담을 수 있는 그릇이다.
  - 한마디로 자바스크립트 배열은 **모든 타입의 값들을 숫자로 인덱싱한 집합**이다.
- 배열의 빈 슬롯은 `undefined`라고 나오지만, 이는 명시적으로 `undefined`를 세팅한 것과 똑같지 않다.
- 배열 값에 `delete` 연산자를 적용하면 슬롯을 제거할 수는 있지만, `length` 프로퍼티 값이 바뀌지 않는다.
- 배열 자체도 하나의 객체여서 키/프로퍼티 문자열을 추가할 수 있다. 하지만 `length`가 증가하지는 않는다.
  - 그런데 키로 넣은 문자열 값이 표준 10진수 숫자로 타입이 바뀌면, 마치 문자열 키가 아닌 숫자 키를 사용한 것 같은 결과가 초래된다.
  ```ts
  let a = [];
  a["13"] = 42;
  a.length; // 14
  ```
- 유사 배열을 일반 배열로 바꾸고 싶다면?
  - 먼저, 유사 배열이란?
    - `[]`로 감싸져 있지만, 배열이 아닌 것들. 예를 들어, `DOM` 쿼리 작업을 수행하면 반환되는 `DOM` 원소 리스트가 유사 배열이다.
    - 유사 배열에 대해 `Array.isArray` 메서드를 사용해서 배열인지 판별하면 `false`가 나온다.
  - 유사 배열에는 배열의 메서드, 이를테면 `forEach` `map` `reduce` 등을 쓸 수 없다. 그래도 사용하고 싶다면, `call`이나 `apply`, 또는 `Array.from`을 쓰면 된다.
    ```ts
    const nodes = document.querySelectorAll("div");
    nodes.forEach((el) => console.log(el)); // Uncaught TypeError
    Array.from(nodes).forEach((el) => console.log(el));
    ```

## 문자열

- 문자열은 문자의 배열이 아니다.
  - 문자열과 배열 모두 `length` 프로퍼티를 갖고, `concat` 메서드도 갖는다. 하지만...
  - 문자열은 불변 값이고 배열은 가변 값이다.
    - 문자열은 불변 값이므로 문자열 메서드는 그 내용을 바로 변경하지 않고 항상 새로운 문자열을 생성한 후 반환한다.
    - 반면 대부분의 배열 메서드는 그 자리에서 곧바로 원소를 수정한다.
    - 문자열에 대해 빌려 쓸 수 있는 배열의 메서드는 **불변** 배열 메서드다. 배열의 가변 메서드는 문자열에 통하지 않는다.
- 문자열 자체에 어떤 작업을 빈번하게 수행하는 경우라면, 차라리 문자열을 문자 단위로 저장하는 배열로 취급하는 게 나을 수 있다.
  - 문자의 배열을 분자열로 나타내야 할 때는 `join` 메서드를 호출하면 된다.

## 숫자

- 자바스크립트의 숫자 타입은 `number`가 유일하다.
  - 정수, 부동 소수점 숫자를 모두 아우른다.
  - 자바스크립트의 정수는 부동 소수점이 없는 값이다.
- 소수점 앞 또는 뒤의 숫자가 0일 때, 이를 생략할 수 있다.
- 숫자에 메서드를 사용할 때, 프로퍼티 연산자의 일부로 사용한 `.`이 숫자 리터럴의 일부로 인식되어 버려 에러가 날 수 있다.

```ts
// 잘못된 구문
42.toFixed(3) // Syntax Error
// 올바른 구문
(42).toFixed(3)
42..toFixed(3)
```

### 작은 소수값

- 자바스크립트에는 널리 알려진 이진 부동 소수점 숫자의 부작용 문제가 있다. 그런데 이는 `IEEE 754` 표준을 따르는 모든 언어에서 나타나는 공통적인 문제로, 자바스크립트만의 문제는 아니다.

```ts
0.1 + 0.2 === 0.3; // false
```

- 이진 부동 소수점으로 나타낸 `0.1`과 `0.2`는 보여지는 그대로와 사실 일치하지 않는다. 그래서 그 둘을 더한 결과 역시 정확히 `0.3`이 아니다. 실제로는 `0.300000004`에 더 가깝지만, 이 숫자와도 연산 결과가 같은 것은 아니다.
- 그렇다면, `0.1 + 0.2`와 `0.3`을 어떻게 비교하면 좋을까?

  - 가장 일반적으로는 미세한 '반올림 오차'를 허용 공차로 처리하는 방법이 있다. 이렇게 미세한 오차를 머신 입실론 `Machine Epsilon`이라고 한다. 머신 입실론은 `2^(-52)`이다.

  ```ts
  function numbersCloseEnoughToEqual(n1, n2) {
    return Math.abs(n1 - n2) < Number.EPSILON;
  }

  const a = 0.1 + 0.2;
  const b = 0.3;

  numbersCloseEnoughToEqual(a, b); // true
  numbersCloseEnoughToEqual(0.0000001, 0.0000002); // false
  ```

- 부동 소수점 숫자의 최댓값은 대략 `1.798e+308`이고, `Number.MAX_VALUE`로 정의한다.
- 부동 소수점 숫자의 최솟값은 대략 `5e-324`로 거의 `0`에 가까운 숫자고 `Number.MIN_VALUE`로 정의한다.

### 안전한 정수 범위

- '안전하게' 표현할 수 있는, 다시 말해 표현한 값과 실제 값이 정확하게 일치한다고 장담할 수 있는 정수는 최대 `2^53 - 1 (=9007199254740991)`이다. 얼추 9천 조가 넘는다. 이 값은 `ES6`에서 `Number.MAX_SAFE_INTEGER`로 정의한다. 최솟값은 `Number.MIN_SAFE_INTEGER`로 정의하며 `-9007199254740991`이다.
- 만약 아주 큰수를 다루어야 한다면?
  - 지금으로서는 큰 수 유틸리티 사용을 권한다. 예를 들면, [BigInteger.js](https://www.npmjs.com/package/biginteger)가 있다.

### 정수인지 확인

- `ES6`부터는 `Number.isInteger()`로 어떤 값의 정수 여부를 확인한다.
- 안전한 정수 여부는 `ES6`부터 `Number.isSafeInteger()`로 확인한다.

## 특수 값

### `undefined`와 `Null`은 어떻게 다를까?

- `undefined` 타입의 값은 `undefined`밖에 없다.
  - `undefined`는 할당된 값이 없는 모든 변수/프로퍼티의 기본 값이다.
- `null` 타입의 값도 `null`밖에 없다.
- (개발자마다 정의에 차이가 있을 수 있겠지만) `null`은 값이 아예 없는 상태, `undefined`는 아직 값을 가지지 않은 상태다.
- 둘의 확실한 차이는, `null`은 식별자가 아닌 특별한 키워드이므로 `null`이라는 변수에 뭔가 할당할 수는 없다는 것, 그런데 `undefined`는 식별자로 쓸 수 있다는 것이다.
  - 식별자란 어떤 대상을 유일하게 식별 및 구별할 수 있는 이름을 말한다.
    ```ts
    function foo() {
      undefined = 2; // 이렇게 할 수 있다 뿐이지 절대 바람직한 방식이 아니다
    }
    ```
- `void` 연산자는 어떤 값이라도 `undefined`로 만들어 버린다. 어떤 표현식로부터 값이 존재하는 곳에서, 어떤 경우에 따라 그 값이 `undefined`가 되어야 함을 명시적으로 표현할 때 유용하다.

### `NaN`, Not a Number, 자기 자신과도 동등하지 않은.

- 수학 연산 시 두 피연산자가 전부 숫자가 아닐 경우, 그 결과값이 유효한 숫자일 수 없다. 이는 `NaN`이다.
- `NaN`은 숫자 아님이 아니라, 유효하지 않은 숫자라고 보는 것이 맞다.
- `NaN`은 사실상 반사성이 없는 유일한 값이다. 이게 무슨 말이냐면,

  ```ts
  const a = 2 / "foo";

  a === NaN; // false
  ```

- 그렇다면 비교불능인 `NaN`은 어떻게 확인할 수 있을까?
  - `Number.isNaN`을 사용하면 된다.

### `INFINITY`

```ts
const a = 1 / 0; // Infinity
const b = -1 / 0; // -Infinity
```

- 자바스크립트에서는 `0`으로 나누기 연산이 잘 정의되어 있어서 에러 없이 `Infinity`라는 결과가 나온다.

### `-0`은 왜 있는걸까?

- 자바스크립트에는 보통의 영(`+0`)과 음의 영(`-0`)이 있다.

```ts
const a = 0 / -3; // -0
const b = 0 * -3; // -0

// 명세에 의하면. -0을 문자열화하면 항상 "0"
a.toString(); // "0"
String(a); // "0"
JSON.stringify(a); // "0"

// 반대로 문자열에서 숫자로 바꾸면 있는 그대로 보여줌
+"-0"; // -0
Number("-0"); // -0
JSON.parse("-0"); // -0
```

- `-0`과 `0`을 구분하고 싶다면, 아래와 같이 해볼 수 있다:

```ts
function isNegZero(n) {
  n = Number(n);
  return n === 0 && 1 / n === -Infinity;
}

isNegZero(-0); // true
isNegZero(0 / -3); // true
isNegZero(0); // false
```

- `+0` `-0`의 개념이 없다면 어떤 변수의 값이 `0`에 도달하여 부호가 바뀌는 순간, 그 직전까지 이 변수의 이동 방향은 무엇이었는지 알 수가 없으므로 부호가 다른 두 `0`은 유용하다. 즉 잠재적인 정보 소실을 방지하기 위해 `0`의 부호를 보존한 셈이다.

### 특수한 동등비교에는 `Object.is()`를 사용하기

- 잡다한 예외를 걱정할 필요없이 두 값이 절대적으로 같은지 확인하는 유틸리티 `Object.is()`를 사용할 수 있다.

```ts
const a = -2 / "foo";
const b = -3 * 0;

Object.is(a, NaN); // true
Object.is(b, -0); // true
Object.is(b, 0); // false
```

- `==`이나 `===`로 두 값의 동등비교가 충분히 이루어질 수 있다면, `Object.is()`는 사용하지 않는 편이 좋다. 왜냐면 기본 연산자가 좀 더 효율이 좋고 일반적이기 때문이다.

## 값 vs 레퍼런스

- 자바스크립트에서의 레퍼런스는 다른 언어의 레퍼런스 또는 포인터와는 전혀 다른 개념으로, 또 다른 변수/레퍼런스가 아닌 오직 자신의 값만을 가리킨다.
  - 포인터란 프로그래밍 언어에서 다른 변수, 혹은 그 변수의 메모리 공간주소를 가리키는 변수를 말한다.
- 자바스크립트에서는 값의 타입만으로 값-복사, 레퍼런스-복사 둘 중 한쪽이 결정된다.
  - `null` `undefined` `string` `number` `boolean` 그리고 `ES6`의 `symbol` 같은 단순 값(스칼라 원시 값)은 언제나 값-복사 방식으로 할당/전달된다.
  - 객체나 함수 등의 합성 값은 할당/전달 시 반드시 레퍼런스 사본을 생성한다.
- 레퍼런스는 변수가 아닌 값 자체를 가리키므로 A 레퍼런스로 B 레퍼런스가 가리키는 대상을 변경할 수는 없다.

  ```ts
  let a = [1, 2, 3];
  let b = a;
  console.log(a); // [1,2,3]
  console.log(b); // [1,2,3]

  b = [4, 5, 6];
  console.log(a); // [1,2,3]
  console.log(b); // [4,5,6]
  ```

  - 위의 예시에서, `b`에 새로운 배열을 할당해도 `a`가 참조하는 `[1,2,3]`은 영향을 받지 않는다. 그렇게 되려면 `b`가 배열을 가리키는 레퍼런스가 아닌 포인터가 되어야 하는데, **자바스크립트에는 포인터가 없다!**

- 배열 같은 합성 값을 값-복사에 의해 효과적으로 전달하려면, _손수 값의 사본을 만들어_ 전달한 레퍼런스가 원본을 가리키지 않게 하면 된다.

  - 예를 들어, `slice()`를 호출하면 전혀 새로운 배열의 (얕은 복사에 의한) 사본을 만든다.

    - 얕은 복사란? 사본을 만들어내지 않고 원본을 참조하도록 복사한 척을 하는 것

    ```ts
    let arr1 = [1, 2, 3, 4];
    let arr2 = arr1;

    console.log(arr1); // [1,2,3,4]
    console.log(arr2); // [1,2,3,4]

    arr2[0] = 0;
    console.log(arr1); // [0,2,3,4]
    console.log(arr2); // [0,2,3,4]
    ```

    - 깊은 복사란?

    ```ts
    let arr1 = [1, 2, 3, 4];
    let arr2 = arr1.slice();

    console.log(arr1); // [1,2,3,4]
    console.log(arr2); // [1,2,3,4]

    arr2[0] = 0;
    console.log(arr1); // [1,2,3,4]
    console.log(arr2); // [0,2,3,4]

    console.log(arr1 === arr2); // false
    ```
