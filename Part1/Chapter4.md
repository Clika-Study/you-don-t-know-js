# Chapter 4. 강제변환

## 4.1 값 변환: 타입 캐스팅 vs. 강제변환

- 타입 캐스팅 `Type Casting`

  - 어떤 값을 다른 타입의 값으로 바꾸는 과정이 명시적일 때
  - 정적 타입 언어에서 컴파일 시점에 발생함
  - 코드만 봐도 의도적으로 타입변환을 일으킨다는 사실이 명백함

- 강제변환 `Coercion`

  - 어떤 값을 다른 타입의 값으로 바꾸는 과정이 암시적일 때
  - 동적 타입 언어에서 런타임 시점에 발생함
  - 다른 작업 도중 불분명한 부수효과로부터 발생함

## 4.2 추상 연산

### `ToString`

- 내장 원시 값(문자열, 숫자, 불린 등)은 본연의 문자열화 방법이 정해져 있다.
  - 숫자는 그냥 문자열로 바뀐다. 너무 작거나 큰 값은 지수 형태로 바뀐다.
- 일반 객체는 기본적으로 `toString()` 메서드가 내부 `[[Class]]`를 반환한다.
- 배열은 기본적으로 재정의된 `toString()`이 있다. 문자열 반환시 모든 우너소 값이 콤마로 분리된 형태로 이어진다.
  ```js
  const a = [1, 2, 3];
  a.toString(); // "1,2,3"
  ```

#### JSON 문자열화 `JSON.stringfy()`

- 대부분 단순 값들에 있어 JSON 문자열화의 결과는 `toString()` 변환의 결과와 동일하다.
- JSON 안전 값이 아닌 것들 (`Non-safe value`: `undefined`, 함수, `Symbol`, 환형 참조 객체(프로퍼티 참조가 무한 순환되는 구조의 객체))의 경우 자동 누락된다.
  - 이런 값들이 배열에 포함되어 있으면 `null`로 바꾼다 (배열 인덱스 정보가 뒤바뀌지 않도록).
  - 이런 값들이 객체 프로퍼티에 있으면 간단히 지워버린다.
  - 환형 참조 객체의 경우, 아예 에러가 난다.

```js
JSON.stringfy(undefined); // undefined
JSON.stringfy(function() {}); // undefined

JSON.stringfy(
  {1,undefined,function(){},4}
); // "{1,null,null,4}"

JSON.stringfy(
  {
    a: 2,
    b: function(){}
  }
); // "{"a":2}"
```

- 부적절한 JSON 값이나 직렬화하기 곤란한 객체 값을 문자열화하려면 `toJSON()` 메서드를 따로 정의해야 한다.
  - `toJSON()` 메서드는 '문자열하기 적당한 JSON 안전 값으로 바꾸는 것'이지, JSON 문자열로 바꾸는 것이 아니다. 후자는 `JSON.stringfy()`가 한다.
- `JSON.stringfy()`의 인자들
  - 두번째 선택 인자로 지정하여 객체를 재귀적으로 직렬화하면서 필터링 하는 방법이 있다.
    - 함수인 대체자는 최초 호출시 객체 자신을 전달하므로 `k`가 `undefined`다.
  - 세번째 선택 인자는 스페이스 (들여쓰기)다.
    - 들여쓰기 할 빈 공간의 개수를 숫자로 지정하거나,
    - 들여쓰기 할 공간을 채워넣을 문자열을 지정할 수 있다.

```js
const a = {
  b: 42,
  c: "42",
  d: [1, 2, 3],
};

JSON.stringfy(a, ["b", "c"]); // {"b":42,"c":"42"}
JSON.stringfy(a, function (k, v) {
  if (k !== "c") return v;
}); // {"b":42,"d":[1,2,3]}
```

### `ToNumber`

- `true` 는 `1`,
- `false`는 `0`,
- 희한하게도 `null`은 `0`이다.
- 문자열은 숫자 리터럴을 반환하지만, 실패하면 `NaN`을 반환한다.
- 8진수는 8진수가 아닌 일반 10진수로 처리된다.
- 객체와 배열은 일단 동등한 원시값으로 변환 후, 그 결과값을 `ToNumber`의 규칙에 의해 강제변환한다.
  - 동등한 원시값으로 바꾸기 위해 해당 객체가 `valueOf()` 메서드를 구현했는지 확인한다.
    - 만약 `valueOf()`를 쓸 수 있고 반환 값이 원시 값이면 그대로 강제변환한다.
    - 그렇지 않은 경우, `toString()` 메서드가 존재한다면 이를 이용하여 강제변환한다.
  - `Object.create(null)`을 이용하여 강제변환이 불가능한 객체를 생성할 수 있다.
    - `valueOf()` `toString()` 메서드가 없는 객체를 말함

```js
const a = {
  valueOf: function () {
    return "42";
  },
};

const b = {
  toString: function () {
    return "42";
  },
};

Number(a); // 42
Number(b); // 42

Number(""); // 0
Number([]); // 0
Number(["abc"]); // NaN
```

### `ToBoolean`

- 많은 오해와 혼동을 불러일으키는 주제..
- 자바스크립트의 모든 값은 다음 둘 중 하나다.
  - 불리언으로 강제변환하면 `false`가 되는 값
  - 위를 제외한 나머지
- 고로 불리언으로 강제변환하였을 때 `false`가 되는 몇 안되는 특별한 겂들을 알면 된다.
  - `undefined`
  - `null`
  - `false`
  - `+0` `-0` `NaN`
  - `""`
- 당연한 말이지만, 위 목록에 없으면 `truthy`한 값으로, 불리언으로 강제변환 시 `true`가 된다.

#### `Falsy` 객체

- 일단 `Falsy` 객체는 `falsy`한 값을 감싼 객체를 말하는 게 아니다.
- `Falsy` 객체는 순수 자바스크립트의 일부도 아니다..(엥?)
- `Falsy` 객체는 겉보기엔 평범한 객체처럼 작동할 것 같지만 불리언으로 강제 변환하면 `false`다.
  - 위의 `Falsy` 값 목록에도 없다시피 빈 객체라고 하더라도 불리언으로 강제 변환하면 `true`가 된다. 그러면 `Falsy` 객체라는 건 대체 뭘까?
  - 특정 브라우저(이를테면 지금은 사실상 사라진 IE)에서 사용되는 비표준에 대응하기 위한 값으로 생성된 것이다.
  - `Falsy` 객체의 가장 유명한 사례가 `DOM`의 유사 배열 객체 `document.all`다.
    - `document.all`의 반환하는 유사 배열 객체가 `falsy`한 값이어야 하는 이유는 정말 황당한데, 비표준이며 비 권장/폐기된 `document.all`을 작성한 코드가 예전과 다를 바 없이 잘 작동하게 놔두면 안되므로 `document.all`이 `falsy`인 것처럼 돌아가게 만든 것이라고 한다. `document.all`에 의존하는 레거시 코드가 많아서 아예 날려버릴 수는 없었다고..

## 4.3 명시적 강제변환 `Type Casting`

### 문자열과 숫자 사이의 강제변환

- `String()`은 값을 받아 원시 문자열로 강제변환한다.
- `Number()`는 `ToNumber` 추상 연산 로직에 의해 어떤 값이든 원시 숫자 값으로 강제변환한다.
- `toString()` 호출

  ```js
  const a = 42;
  const b = a.toString();

  b; // "42"
  ```

  - `toString()` 메서드가 없다면 엔진은 `toString()` 메서드를 사용할 수 있도록 자동으로 `42`를 객체 래퍼로 '박싱'한다. 객체 래퍼로 박싱하는 것은 암시적으로 일어나는 일이므로, 즉 `toString()` 메서드를 이용한 강제변환은 '명시적으로, 암시적인' 작동이라고 할 수 있다.

  ```js
  const c = "3.14";
  const d = +c;

  d; // 3.14
  ```

  - 위의 예시에서 `+c`의 `+`는 단항 연산자다.
    - 이는 덧셈이나 문자열 붙이기를 하기 위한 덧셈 부호가 아니라 피연산자 `c`를 숫자로 명시적 강제변환하는 연산자다.
    - 그런데 이걸 '명시적'이라고 할 수 있을까? 개발자의 경험에 따라 다를 것.

#### 날짜와 숫자 사이의 강제변환

- `+` 단항 연산자는 날짜/시각 값을 유닉스 타임스탬프 표현형으로 변환하는 데에도 쓰인다.
- (권장) 위와 같이 강제변환하지 않더라도 `Date` 객체로부터 타임스탬프를 얻을 수 있다.

```js
const timestamp = new Date().getTime();
// 또는
const timestamp2 = Date.now();
```

#### 이상한 나라의 틸드 `~`

- `~`가 뭐지?
  - 이 연산자는 먼저 32비트 숫자로 강제변환한 후 `NOT` 연산을 한다 (각 비트를 거꾸로 뒤집는다)

### 숫자 형태의 문자열 파싱: `parseInt`와 `Number`의 차이 알기

- 문자열로부터 숫자 값의 파싱은 비 숫자형 문자를 허용한다.
  `parseInt()`의 인자로는 문자열만 가능하다. 만약 문자열이 아니라면, (처리 자체를 거부하고 에러를 던지는 대신) 우선 인자를 문자 타입으로 강제변환한다. (이러한 암시적 작동은 권장되지 않음)
- 반면 강제변환은 비 숫자형 문자를 허용하지 않기 때문에 `NaN`을 반환한다.

```js
const a = "42";
const b = "42px";

Number(a); // 42
Number(b); // NaN
parseInt(a); // 42
parseInt(b); // 42
```

### 비 불리언에서 불리언으로의 강제변환 `Boolean()`

- `Boolean()`은 인자로 받은 값이 `falsy`한 경우 `false`를 반환하고, 그렇지 않으면 `true`를 반환한다.
- `!` 부정 단항 연산자는 값을 불리언으로 강제변환하는데, 한번만 사용하면 결과를 반대로 뒤집기 때문에 한번 더 사용해야 원래 표현식의 `true/false` 값을 얻을 수 있다.

## 4.4 암시적 변환 `Coercion`

- 개발자가 보기에 분명하지 않은 타입변환은 모두 이 범주에 속한다.
- 자바스크립트 강제변환에 대한 대부분의 불평불만은 암시적 변환에 관한 것이다.
  - 피하는 게 답일까? 자바스크립트 언어 설계의 버그일까?

### 문자열과 숫자 사이의 암시적 변환

#### `+` 연산자와 `String()`을 이용한 문자열 변환의 차이

```js
const a = "42";
const b = "0";

const c = 42;
const d = 0;

a + b; // "420"
c + d; // 42
```

- `+` 연산자가 '숫자의 덧셈, 문자열 접합' 중 어떤 연산을 해야할지 자바스크립트 엔진은 어떻게 알 수 있을까?

```js
const a = [1, 2];
const b = [3, 4];

a + b; // "1,23,4"
```

- 위의 예시에서 피연산자 `a` `b` 모두 문자열이 아니지만 분명히 둘 다 문자열로 강제변환된 후 접합됐다.
- `+` 알고리즘은 한쪽 피연산자가 문자열이거나, 문자열 표현형으로 나타낼 수 있다면 "문자열 접합"을 한다.

```js
const a = {
  valueOf: function () {
    return 42;
  },
  toString: function () {
    return 4;
  },
};

a + ""; // "42"
String(a); // "4"
```

- 전자 `a + ""`는 `ToPrimitive` 연산 과정에서 `a`값을 `valueOf()` 메서드에 전달하여 호출하고, 그 결과값은 `ToString` 추상 연산을 하여 최종적인 문자열로 변환된다.
- 그러나 후자 `String(a)`는 `toString()`을 직접 호출한다.
- 즉 평범한 원시 숫자 값이 아닌 객체라면 어떤 방법으로 문자열 변환을 하는지에 따라 그 결과값이 달라질 수 있다.

#### `-` 연산자를 이용한 강제 변환

- `-` 연산자는 '숫자 뺄셈' 기능이 전부이므로 숫자가 아닌 피연산자를 숫자로 강제변환한다.

  - `*`나 `/` 연산자도 마찬가지다.

  ```js
  const a = [3];
  const b = [1];

  a - b; // 2
  ```

  - 위의 예시에서 배열은 우선 문자열로 강제변환된 뒤, 숫자로 다시 강제변환된다.

- `String(a)`과 `a + ""` 가운데 자바스크립트 프로그램에서는 후자(암시적 강제변환)가 훨씬 많이 사용된다고 한다. (왤까?)

### 비 불리언에서 불리언으로의 암시적 변환

- 다음은 불리언으로의 암시적인 강제변환이 일어나는 표현식을 열거한 것이다.
  1. `if ()` 문의 조건 표현식
  2. `for ( ; ; )`에서 두번째 조건 표현식
  3. `while ()` 및 `do-while()` 루프의 조건 표현식
  4. `? :` 삼항 연산 시 첫번째 조건 표현식
  5. `||` 및 `&&`의 좌측 피연산자

### `&&`와 `||` 연산자

- `&&` 또는 `||` 연산자의 결과값이 반드시 불리언 타입이어야 하는 것은 아니며 항상 두 피연산자 표현식 중 어느 한쪽 값으로 귀결된다.

- 첫번째 피연산자의 불리언 값을 평가한다. 피연산자가 비 불리언 타입이면 먼저 `ToBoolean`으로 강제변환 후 평가를 계속한다.

  - `||` 연산자는 그 결과가 `true`면 첫번째 피연산자 값을, `false`면 두번째 피연산자 값을 반환한다.
  - `&&` 연산자는 반대로 작동한다.

### 심벌의 강제변환

- 심벌에서 문자열로의 명시적 강제변환은 허용되지만,
- 심벌에서 문자열로의 암시적 강제변환은 금지되며 시도만 해도 에러가 발생한다.

```js
const s1 = Symbol("apple");
String(s1); // "Symbol(apple)"

const s2 = Symbol("kiwi");
s2 + ""; // TypeError
```

## 4.5 느슨한/엄격한 동등 비교

- 느슨한 동등 비교는 `==` 연산자를 사용한다.
- 엄격한 동등 비교는 `===` 연산자를 사용한다.
- 동등함의 비교 시 `==`는 강제변환을 허용하지만 `===`는 강제변환을 허용하지 않는다.
  - 다음은 두 가지 동등 비교에 대한 흔한 오해다: `==`는 값의 동등함만을, `===`는 값과 타입 모두의 동등함을 비교한다.(?!)

### 비교 성능

- 두 피연산자의 타입이 다른 경우 강제변환을 해야 하므로 `==`가 더 할일이 많다.
  - 하지만 강제변환 시 약간 더 소요되는 처리 시간은 고작 몇 마이크로 초 단위의 차이일 뿐이다.
- 타입이 다른 두 값의 동등 비교에서 성능은 중요한 포인트가 아니다. 자문해야 할 사항은 "비교 과정에서 강제변환의 개입 여부"!
  - 강제변환이 필요하다면 느슨한 동등 연산자를, 필요하지 않다면 엄격한 동등 연산자를 사용하자

### 추상 동등 비교

#### 1. 비교하기: 문자열에서 숫자로의 강제변환

```js
const a = 42;
const b = "42";

a === b; // false
a == b; // true
```

- 결과는 예상대로지만 다음의 의문이 남는다:
  - 느슨한 동등 비교에서는 정확히 어떻게 강제변환이 일어나는 걸까? `42`가 문자열로 바뀌는 걸까 아니면 `"42"`가 숫자로 바뀌는 걸까?
    - 명세에 따르면, 앞에 있는 피연산자의 타입이 강제변환된다.

#### 2. 비교하기: 비 불리언에서 불리언으로의 강제변환

```js
const a = "42";
const b = true;

a == b; // false
```

- 명세에 따르면,
  - `Type(x)`가 불리언이면, `ToNumber(x) == y`의 비교 결과를 반환한다.
  - `Type(y)`가 불리언이면, `x == ToNumber(y)`의 비교 결과를 반환한다.

```js
const a = true;
const b = "42";

a == b; // false
```

#### 3. 비교하기: `null`에서 `undefined`로의 강제변환

- 다시 한번 명세를 보면,
  - `x`가 `null`이고 `y`가 `undefined`면 `true`를 반환한다.
  - `x`가 `undefined`고 `y`가 `null`이면 `true`를 반환한다.
- 즉 `null`과 `undefined`는 느슨한 동등 비교를 할 때 서로에게 타입을 맞춘다.

```js
const a = doSomething();

if (a === undefined || a === null) {
  // ...
}

// 위와 같이 하는 대신,
// 아래처럼 하는 게 훨씬 간결하다 (성능 측면에서도 더 낫다)
if (a == null) {
  // ...
}
```

#### 4. 비교하기: 객체에서 비객체로의 강제변환

- 객체/함수/배열과 단순 스칼라 원시 값(숫자, 문자열, 불리언)의 비교는 다음과 같은 기준으로 이루어진다:
  - `Type(x)`가 문자열 또는 숫자이고, `Type(y)`가 객체라면, `x == ToPrimitive(y)`의 비교 결과를 반환한다.
  - `Type(x)`가 객체고, `Type(y)`가 문자열 또는 숫자라면, `ToPrimitive(x) == y`의 비교 결과를 반환한다.
- 즉, 양측 피연산자 가운데 객체인 쪽에 `ToPrimitive` 추상 연산을 한 결과값과 동등 비교를 한다는 뜻이다.

### 암시적 강제변환의 안전한 사용법

1. 피연산자 중 하나가 `true/false`일 가능성이 있다면 절대로 `==` 연산자를 쓰지 말자.
2. 피연산자 중 하나가 `[]`, `" "`, `0`이 될 가능성이 있으면 가급적 `==` 연산자를 쓰지 말자.

## 4.6 추상 관계 비교

- 추상적 관계 비교는 두 피연산자 모두 문자열일 때와 그 외의 경우일 때로 나뉜다.
- 이 알고리즘은 먼저 두 피연산자에 대해 `ToPrimitive` 강제변환을 실시하는 것으로 시작한다.

  - 그 결과, 어느 한쪽이라도 문자열이 아닌 경우 양쪽 모두 `ToNumber`로 강제변환하여 숫자값으로 만들어 비교한다.
  - 두쪽 모두 문자열 값이면, 각 문자를 단순 어휘로 비교한다.

  ```js
  const a = ["42"];
  const b = ["043"];

  a < b; // false
  ```

  ```js
  const x = { y: 42 };
  const y = { y: 43 };

  x < y; // false
  x == y; // false
  x > y; // false

  x <= y; // true
  x >= y; // true
  ```

  - `x == y`는 왜 `true`가 아닐까?
    - 둘 다 동일한 문자열 `[object Object]`라고 하더라도, 문자열로 강제변환되기 전의 각각의 두 객체가 정확히 똑같은 값에 대한 레퍼런스일 경우에만 동등하다고 할 수 있다. 여기서 `x`와 `y`는 아예 값 자체도 다른 별개의 객체다.
  - `x <= y` `x >= y`는 어떻게 `true`일까?
    - `x <= y`는 `x < y`의 평가 결과를 부정하도록 명세에 기술되어있기 때문이다.

---

### 이번 챕터를 공부하면서 든 생각들..

- 명시적/암시적이라는 표현은 역시 애매하다.
- 우리 회사 코드에서는 종종 어떤 값이 `undefined`이거나 `null`인 경우를 판별하기 위해 `lodash`의 `isNil`을 사용하는데, - 이를테면 다음과 같이,
  ```js
  if (_.isNil(x)) {
    // ..
  }
  ```
  느슨한 동등 비교에서 `null`과 `undefined`가 구분되지 않는 점, 그리고 이 두 타입이 다른 `falsy`한 값들과의 비교에서는 `false`를 반환하는 점을 활용하여, `lodash`라는 외부 라이브러리를 사용할 필요없이 다음과 같이 리팩토링할 수 있을 것이다. 적어도 이 책의 작가는 그렇게 하기를 권할 것 같다.
  ```js
  if (x == null) {
    // ..
  }
  ```
