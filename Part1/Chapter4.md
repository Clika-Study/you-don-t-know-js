# Chapter 4. 강제변환

## 4.1 값 변환: 타입 캐스팅 vs. 강제변환

- 타입 캐스팅 `Type Casting`

  - 어떤 값을 다른 타입의 값으로 바꾸는 과정이 명시적일 때
  - 정적 타입 언어에서 컴파일 시점에 발생함
  - 코드만 봐도 의도적으로 타입변환을 일으킨다는 사실이 명백함

- 강제변환 `Coercion`

  - 어떤 값을 다른 타입의 값으로 바꾸는 과정이 암시적일 때
  - 동적 타입 언어에서 런타임 시점에 발생함
  - 다른 작업 도중 불분명한 부수효과로부터 발생함

## 4.2 추상 연산

### `ToString`

- 내장 원시 값(문자열, 숫자, 불린 등)은 본연의 문자열화 방법이 정해져 있다.
  - 숫자는 그냥 문자열로 바뀐다. 너무 작거나 큰 값은 지수 형태로 바뀐다.
- 일반 객체는 기본적으로 `toString()` 메서드가 내부 `[[Class]]`를 반환한다.
- 배열은 기본적으로 재정의된 `toString()`이 있다. 문자열 반환시 모든 우너소 값이 콤마로 분리된 형태로 이어진다.
  ```js
  const a = [1, 2, 3];
  a.toString(); // "1,2,3"
  ```

#### JSON 문자열화 `JSON.stringfy()`

- 대부분 단순 값들에 있어 JSON 문자열화의 결과는 `toString()` 변환의 결과와 동일하다.
- JSON 안전 값이 아닌 것들 (`Non-safe value`: `undefined`, 함수, `Symbol`, 환형 참조 객체(프로퍼티 참조가 무한 순환되는 구조의 객체))의 경우 자동 누락된다.
  - 이런 값들이 배열에 포함되어 있으면 `null`로 바꾼다 (배열 인덱스 정보가 뒤바뀌지 않도록).
  - 이런 값들이 객체 프로퍼티에 있으면 간단히 지워버린다.
  - 환형 참조 객체의 경우, 아예 에러가 난다.

```js
JSON.stringfy(undefined); // undefined
JSON.stringfy(function() {}); // undefined

JSON.stringfy(
  {1,undefined,function(){},4}
); // "{1,null,null,4}"

JSON.stringfy(
  {
    a: 2,
    b: function(){}
  }
); // "{"a":2}"
```

- 부적절한 JSON 값이나 직렬화하기 곤란한 객체 값을 문자열화하려면 `toJSON()` 메서드를 따로 정의해야 한다.
  - `toJSON()` 메서드는 '문자열하기 적당한 JSON 안전 값으로 바꾸는 것'이지, JSON 문자열로 바꾸는 것이 아니다. 후자는 `JSON.stringfy()`가 한다.
- `JSON.stringfy()`의 인자들
  - 두번째 선택 인자로 지정하여 객체를 재귀적으로 직렬화하면서 필터링 하는 방법이 있다.
    - 함수인 대체자는 최초 호출시 객체 자신을 전달하므로 `k`가 `undefined`다.
  - 세번째 선택 인자는 스페이스 (들여쓰기)다.
    - 들여쓰기 할 빈 공간의 개수를 숫자로 지정하거나,
    - 들여쓰기 할 공간을 채워넣을 문자열을 지정할 수 있다.

```js
const a = {
  b: 42,
  c: "42",
  d: [1, 2, 3],
};

JSON.stringfy(a, ["b", "c"]); // {"b":42,"c":"42"}
JSON.stringfy(a, function (k, v) {
  if (k !== "c") return v;
}); // {"b":42,"d":[1,2,3]}
```

### `ToNumber`

- `true` 는 `1`,
- `false`는 `0`,
- 희한하게도 `null`은 `0`이다.
- 문자열은 숫자 리터럴을 반환하지만, 실패하면 `NaN`을 반환한다.
- 8진수는 8진수가 아닌 일반 10진수로 처리된다.
- 객체와 배열은 일단 동등한 원시값으로 변환 후, 그 결과값을 `ToNumber`의 규칙에 의해 강제변환한다.
  - 동등한 원시값으로 바꾸기 위해 해당 객체가 `valueOf()` 메서드를 구현했는지 확인한다.
    - 만약 `valueOf()`를 쓸 수 있고 반환 값이 원시 값이면 그대로 강제변환한다.
    - 그렇지 않은 경우, `toString()` 메서드가 존재한다면 이를 이용하여 강제변환한다.
  - `Object.create(null)`을 이용하여 강제변환이 불가능한 객체를 생성할 수 있다.
    - `valueOf()` `toString()` 메서드가 없는 객체를 말함

```js
const a = {
  valueOf: function () {
    return "42";
  },
};

const b = {
  toString: function () {
    return "42";
  },
};

Number(a); // 42
Number(b); // 42

Number(""); // 0
Number([]); // 0
Number(["abc"]); // NaN
```

### `ToBoolean`

- 많은 오해와 혼동을 불러일으키는 주제..
- 자바스크립트의 모든 값은 다음 둘 중 하나다.
  - 불리언으로 강제변환하면 `false`가 되는 값
  - 위를 제외한 나머지
- 고로 불리언으로 강제변환하였을 때 `false`가 되는 몇 안되는 특별한 겂들을 알면 된다.
  - `undefined`
  - `null`
  - `false`
  - `+0` `-0` `NaN`
  - `""`
- 당연한 말이지만, 위 목록에 없으면 `truthy`한 값으로, 불리언으로 강제변환 시 `true`가 된다.

#### `Falsy` 객체

- 일단 `Falsy` 객체는 `falsy`한 값을 감싼 객체를 말하는 게 아니다.
- `Falsy` 객체는 순수 자바스크립트의 일부도 아니다..(엥?)
- `Falsy` 객체는 겉보기엔 평범한 객체처럼 작동할 것 같지만 불리언으로 강제 변환하면 `false`다.
  - 위의 `Falsy` 값 목록에도 없다시피 빈 객체라고 하더라도 불리언으로 강제 변환하면 `true`가 된다. 그러면 `Falsy` 객체라는 건 대체 뭘까?
  - 특정 브라우저(이를테면 지금은 사실상 사라진 IE)에서 사용되는 비표준에 대응하기 위한 값으로 생성된 것이다.
  - `Falsy` 객체의 가장 유명한 사례가 `DOM`의 유사 배열 객체 `document.all`다.
    - `document.all`의 반환하는 유사 배열 객체가 `falsy`한 값이어야 하는 이유는 정말 황당한데, 비표준이며 비 권장/폐기된 `document.all`을 작성한 코드가 예전과 다를 바 없이 잘 작동하게 놔두면 안되므로 `document.all`이 `falsy`인 것처럼 돌아가게 만든 것이라고 한다. `document.all`에 의존하는 레거시 코드가 많아서 아예 날려버릴 수는 없었다고..

## 4.3 명시적 강제변환 `Type Casting`

### 문자열과 숫자 사이의 강제변환

- `String()`은 값을 받아 원시 문자열로 강제변환한다.
- `Number()`는 `ToNumber` 추상 연산 로직에 의해 어떤 값이든 원시 숫자 값으로 강제변환한다.
- `toString()` 호출

  ```js
  const a = 42;
  const b = a.toString();

  b; // "42"
  ```

  - `toString()` 메서드가 없다면 엔진은 `toString()` 메서드를 사용할 수 있도록 자동으로 `42`를 객체 래퍼로 '박싱'한다. 객체 래퍼로 박싱하는 것은 암시적으로 일어나는 일이므로, 즉 `toString()` 메서드를 이용한 강제변환은 '명시적으로, 암시적인' 작동이라고 할 수 있다.

  ```js
  const c = "3.14";
  const d = +c;

  d; // 3.14
  ```

  - 위의 예시에서 `+c`의 `+`는 단항 연산자다.
    - 이는 덧셈이나 문자열 붙이기를 하기 위한 덧셈 부호가 아니라 피연산자 `c`를 숫자로 명시적 강제변환하는 연산자다.
    - 그런데 이걸 '명시적'이라고 할 수 있을까? 개발자의 경험에 따라 다를 것.

#### 날짜와 숫자 사이의 강제변환

- `+` 단항 연산자는 날짜/시각 값을 유닉스 타임스탬프 표현형으로 변환하는 데에도 쓰인다.
- (권장) 위와 같이 강제변환하지 않더라도 `Date` 객체로부터 타임스탬프를 얻을 수 있다.

```js
const timestamp = new Date().getTime();
// 또는
const timestamp2 = Date.now();
```

#### 이상한 나라의 틸드 `~`

- `~`가 뭐지?
  - 이 연산자는 먼저 32비트 숫자로 강제변환한 후 `NOT` 연산을 한다 (각 비트를 거꾸로 뒤집는다)

### 숫자 형태의 문자열 파싱: `parseInt`와 `Number`의 차이 알기

- 문자열로부터 숫자 값의 파싱은 비 숫자형 문자를 허용한다.
  `parseInt()`의 인자로는 문자열만 가능하다. 만약 문자열이 아니라면, (처리 자체를 거부하고 에러를 던지는 대신) 우선 인자를 문자 타입으로 강제변환한다. (이러한 암시적 작동은 권장되지 않음)
- 반면 강제변환은 비 숫자형 문자를 허용하지 않기 때문에 `NaN`을 반환한다.

```js
const a = "42";
const b = "42px";

Number(a); // 42
Number(b); // NaN
parseInt(a); // 42
parseInt(b); // 42
```

### 비 불리언에서 불리언으로의 강제변환 `Boolean()`

- `Boolean()`은 인자로 받은 값이 `falsy`한 경우 `false`를 반환하고, 그렇지 않으면 `true`를 반환한다.
- `!` 부정 단항 연산자는 값을 불리언으로 강제변환하는데, 한번만 사용하면 결과를 반대로 뒤집기 때문에 한번 더 사용해야 원래 표현식의 `true/false` 값을 얻을 수 있다.

## 4.4 암시적 변환 `Coercion`

### 암시적이란?

### 문자열과 숫자 사이의 암시적 변환

### 불리언에서 숫자로의 암시적 변환

### 비 불리언에서 불리언으로의 암시적 변환

### `&&`와 `||` 연산자

## 4.5 느슨한/엄격한 동등 비교

### 비교 성능

### 추상 동등 비교

### 희귀 사례

## 4.6 추상 관계 비교

---

### 확실하게 알고 넘어가기

- 정적 타입 언어와 동적 타입 언어란?
- 컴파일과 런타임은 뭘까?
- 파싱이란?

### 이번 챕터를 공부하면서 든 생각들..

- 명시적/암시적이라는 표현은 역시 애매하다.
